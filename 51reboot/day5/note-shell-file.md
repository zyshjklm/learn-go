
## 获取输入的几种方式

1 祼读写

```go
	f, err := os.Open("a.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	buf := make([]byte, 4096)

	// 祼读取，很少使用
	n, err := f.Read(buf)
	fmt.Println(string(buf[:n]))
```

2 使用bufio

```go
	r := bufio.NewReader(f)
	// 加上buffer的读取，更高效。
	r.Read(buf)
	// r 有多种Read方式可选。
```

3 按行读取，按分隔符读取

```go
	// 按行读取，按分隔符读取
	// r = bufio.NewScanner()

```

4 小文件 

```go
	// 小文件，一次读取
	ioutil.ReadFile("a.txt")
```

5 通常操作

```go
	// 通常文件操作方法
	// io.Copy()
```

1 bufio.NewReader

```go

r := bufio.NewReader(os.Stdin)
line, _ := r.ReadString('\n')
line = strings.TrimSpace(line)

```

2 buf.NewScanner

```go

r := bufio.NewScanner(os.Stdin)
if !r.Scan() {
    fmt.Println(r.Err())
    break
}
line := r.Text()

```

## 关于Scanner

```go
func NewScanner(r io.Reader) *Scanner
// NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines.

func (s *Scanner) Scan() bool
// Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. 
// It returns false when the scan stops, either by reaching the end of the input or an error. 
// After Scan returns false, the Err method will return any error that occurred during scanning, 
// except that if it was io.EOF, Err will return nil. 

func (s *Scanner) Err() error
// Err returns the first non-EOF error that was encountered by the Scanner.

func (s *Scanner) Text() string
// Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.

```

