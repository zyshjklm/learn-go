## 第13次课

上课时间：2017.0826

### 后继课程内容

rpc

web

db

二进制



### 作业点评

有人添加采集项的函数是阻塞的。这会导致需要在主函数中go该函数。最好是底层实现并发。

```go
sched.AddMetric(CpuMetric, time.Second)
// 这里只是关心一次添加操作。不应该在这里阻塞。
// 应该在内部使用go 协程。而不是让调用方添加协程。
```



#### 网络的错误处理涉及到：

用户态，内核态，对方服务。路由器，交换机。

常见问题：

* 网络中的路由将你的包丢弃或者拥塞时，客户端会有什么表现？
* 拨网线服务会有什么反应？
* 服务端将程序停掉，客户端会有什么表现？



网络连接中，tcp并不是物理连接，而是虚拟的。当拨掉网线时，需要看操作系统是否通知上层应用。如果没有数据发送时，通常不会直接感知到网络问题。以为连接依然存在。



* 三次握手
  * c: syn。net.Dial()发起连接
  * s: ack+syn。net.Listen()监听连接请求
  * c: ack
* 4次挥手。双方都使用conn.Close()请求关闭
  * 主动方为c or s。
    * c:fin
    * s:ack
  * 被动方
    * s: fin
  * c: ack



**处理假死：**

* 心跳包。没事也要经常联系
* 超时机制。超过时间就认为异常了




### 用户自定义监控项

agent中，默认集成的采集项，都有对应的函数。因此直接在调度中添加就可以了。

但对于自定义的监控项，需要调用额外的脚本，而默认的add函数的第一个参数是一个没有参数的函数。

```go
sched.AddMetric(MemMetric, time.Second*5)

// 自定义监控项
sched.AddMetric(NewUserMetric("./userDef.py"), time.Second*90)
```

原本是直接给一个函数的，现在需要根据一个脚本做参数，再返回一个函数，因此要使用闭包来返回这个函数。

实现闭包的思路：

* 先实现一个getUserMetrics()函数，以脚本名为参数，并返回同默认监控项一样的值。
* MemMetric()是没有参数的，getUserMetrics()是脚本名为参数
* 转换的关键就是实现一个闭包NewUserMetric()，返回getUserMetrics()

